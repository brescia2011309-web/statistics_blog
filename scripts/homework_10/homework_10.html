<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Counting processes and Poisson approximation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;200&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0d0d0d; color: #e5e7eb; }
        :root { --neon-color: #FAFAFA; --accent-color: #00FFC2; }
        .brutal-border { border: 4px solid var(--neon-color); transition: all 0.15s ease-out; }
        .brutal-border:hover { transform: translate(-3px, -3px); box-shadow: 3px 3px 0 var(--neon-color), 0 0 8px rgba(250,250,250,0.3); }
        .cyber-mono { font-family: monospace; }
        .text-neon { color: var(--neon-color); }
        .section-header { border-left: 8px solid var(--neon-color); padding-left: 1rem; margin-bottom: 1.5rem; }
        .code-block { background: #111827; padding: 1rem; border: 2px solid var(--neon-color); overflow-x: auto; }
    .cyber-input { background-color: #1f2937; color: var(--neon-color); border: 2px solid var(--neon-color); padding: 0.5rem; }
    .cyber-button { background-color: var(--neon-color); color: #0d0d0d; border: 2px solid var(--neon-color); padding: 0.5rem 1rem; font-weight:700; }
    .code-block canvas { background-color: transparent; display: block; }
    </style>
</head>
<body class="text-gray-200">
    <header class="bg-black p-6 border-b-4 border-neon">
        <div class="container mx-auto flex justify-between items-center">
            <a href="../index.html" class="text-sm font-mono tracking-wider text-neon hover:text-gray-400 transition-colors">← /MAIN_INDEX</a>
            <span class="text-sm font-mono tracking-wider text-gray-500">//COUNTING_PROCESS</span>
        </div>
    </header>

    <main class="container mx-auto px-6 md:px-12 py-12">
        <h1 class="text-4xl font-black uppercase mb-6 text-neon cyber-mono tracking-tight">Counting processes & Poisson approximation</h1>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Task</h2>
            <p class="text-gray-300">Simulate a counting process over interval <code class="cyber-mono">[0, T]</code> where events occur independently and uniformly in time at constant average rate <code class="cyber-mono">λ</code>. Approximate the process by dividing the interval into <code class="cyber-mono">n</code> small subintervals and generating an event in each with probability <code class="cyber-mono">λ * T / n</code> (Bernoulli approximation). Analyze the resulting process and identify the limiting stochastic process as <code class="cyber-mono">n → ∞</code>.</p>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Simulation controls</h2>

            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4">
                <div>
                    <label class="text-xs text-gray-400">Interval length T</label>
                    <input id="inpT" type="number" step="0.1" min="0.01" value="1" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Rate λ (events per unit time)</label>
                    <input id="inpLambda" type="number" step="0.1" min="0" value="3" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Subintervals n</label>
                    <input id="inpN" type="number" min="10" max="200000" value="5000" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Replicates m</label>
                    <input id="inpM" type="number" min="1" max="20000" value="1000" class="cyber-input w-full" />
                </div>
                <div class="flex items-end">
                    <button id="runBtn" class="cyber-button w-full">Run simulation</button>
                </div>
            </div>
            <div class="text-gray-400 text-sm">Default uses Bernoulli approximation: p = λ*T/n. For large n the count at time T approximates Poisson(λT). Beware high m*n combinations may be slow in the browser.</div>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Visual results</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="code-block">
                    <canvas id="pathChart" height="180"></canvas>
                </div>
                <div class="code-block">
                    <canvas id="countHist" height="180"></canvas>
                </div>
            </div>
            <div class="mt-4 code-block">
                <h3 class="text-neon">Interarrival times (aggregated)</h3>
                <canvas id="iaHist" height="120"></canvas>
            </div>
            <div id="summary" class="mt-4 text-gray-300"></div>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Theory & analysis</h2>
            <p class="text-gray-300">The Bernoulli approximation (divide interval into n subintervals and generate events with probability p=λT/n) creates counts with distribution <code class="cyber-mono">Binomial(n, p)</code>. For fixed λT and n→∞ with p=λT/n, the Binomial(n,p) converges to <code class="cyber-mono">Poisson(λT)</code>. The counting process formed by N(t) = # events in [0,t] (with independent increments and stationary increments) in the limit is the Poisson process with rate λ.</p>
            <ul class="ml-6 text-gray-300">
                <li><strong>Poisson process properties</strong>: N(0)=0, independent increments, stationary increments: N(t+s)-N(t) ~ Poisson(λ s).</li>
                <li><strong>Interarrival times</strong>: iid Exponential(λ) — memoryless; the waiting time between successive events has density λ e^{-λ x}.</li>
                <li><strong>Mean and variance</strong>: E[N(t)]=Var(N(t))=λ t for the Poisson process (equal mean and variance).</li>
                <li><strong>Interpretation of λ</strong>: average rate of events per unit time; in physical systems it's an arrival intensity (higher λ → more frequent events, shorter mean interarrival 1/λ).</li>
            </ul>
        </section>

    </main>

    <script>
        // Helpers
        function factorial(k){ if(k<=1) return 1; let f=1; for(let i=2;i<=k;i++) f*=i; return f; }
        function poissonPmf(k, lambdaT){ return Math.exp(-lambdaT) * Math.pow(lambdaT, k) / factorial(k); }

        // Bernoulli approximation path generator: returns event times within [0,T]
        function generatePath(n, T, lambda){
            const p = Math.min(1, lambda * T / n);
            const dt = T / n;
            const times = [];
            for(let i=0;i<n;i++){
                if(Math.random() < p){
                    // place event uniformly within subinterval for better approximation
                    const t = (i + Math.random()) * dt;
                    times.push(t);
                }
            }
            times.sort((a,b)=>a-b);
            return times;
        }

        // Histogram utility: returns bins centers and densities (normalized to area 1)
        function histogramDensity(data, bins){
            const min = 0; const max = Math.max(...data, 1e-6);
            const bw = (max - min) / bins || 1/bins;
            const counts = new Array(bins).fill(0);
            for(const x of data){
                let idx = Math.floor((x - min) / (max - min + 1e-12) * bins);
                if(idx < 0) idx = 0; if(idx >= bins) idx = bins - 1;
                counts[idx]++;
            }
            const total = data.length || 1;
            const centers = [];
            const densities = [];
            for(let i=0;i<bins;i++){
                const left = min + i * bw;
                const center = left + bw/2;
                centers.push(center);
                densities.push(counts[i] / (total * bw));
            }
            return {centers, densities, bw};
        }

        let pathChart=null, countHist=null, iaHist=null;

        // Improve Chart.js default colors for dark theme
        (function(){
            try{
                const root = getComputedStyle(document.documentElement);
                const NEON = (root.getPropertyValue('--neon-color') || '#FAFAFA').trim();
                Chart.defaults.color = NEON;
                Chart.defaults.font.family = "'Inter', sans-serif";
                Chart.defaults.elements.line.borderColor = 'rgba(250,250,250,0.9)';
                Chart.defaults.plugins.legend.labels.color = NEON;
            }catch(e){ console.warn('Chart default config failed', e); }
        })();

        document.getElementById('runBtn').addEventListener('click', ()=>{
            const T = parseFloat(document.getElementById('inpT').value);
            const lambda = parseFloat(document.getElementById('inpLambda').value);
            const n = parseInt(document.getElementById('inpN').value, 10);
            const m = parseInt(document.getElementById('inpM').value, 10);
            if(isNaN(T) || T<=0) { alert('T must be > 0'); return; }
            if(isNaN(lambda) || lambda<0) { alert('λ must be >= 0'); return; }
            if(isNaN(n) || n<1) { alert('n must be >= 1'); return; }
            if(isNaN(m) || m<1) { alert('m must be >= 1'); return; }

            // Safety cap
            const MAX_TRIALS = 20000000; // product cap
            if(m * n > MAX_TRIALS){ if(!confirm('Large m*n may be slow. Continue?')) return; }

            const t0 = performance.now();

            const counts = [];
            const interarrivals = [];
            let firstPathTimes = null;

            for(let rep=0; rep<m; rep++){
                const times = generatePath(n, T, lambda);
                if(rep===0) firstPathTimes = times;
                counts.push(times.length);
                // collect interarrival times
                for(let i=0;i<times.length;i++){
                    if(i===0) interarrivals.push(times[0]);
                    else interarrivals.push(times[i] - times[i-1]);
                }
            }

            const t1 = performance.now();

            // Build charts
            // 1) Sample path (first path) step function
            const pathLabels = [];
            const pathData = [];
            // create step points including (0,0) and (T, final count)
            let cum = 0; let ti=0;
            pathLabels.push(0); pathData.push(0);
            if(firstPathTimes){
                for(const t of firstPathTimes){
                    // step just before event
                    pathLabels.push(t - 1e-6);
                    pathData.push(cum);
                    cum += 1;
                    pathLabels.push(t);
                    pathData.push(cum);
                }
            }
            pathLabels.push(T);
            pathData.push(cum);

            if(pathChart) pathChart.destroy();
            const ctx1 = document.getElementById('pathChart').getContext('2d');
            const pathConfig = {
                type: 'line',
                data: { labels: pathLabels, datasets: [{ label: 'Sample path N(t)', data: pathData, borderColor: 'rgba(0,255,194,0.9)', borderWidth: 2, fill: false, stepped: true }] },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'time' }, ticks: { color: 'var(--neon-color)' }, grid: { color: '#111827' } },
                        y: { title: { display: true, text: 'N(t)' }, ticks: { color: 'var(--neon-color)' }, grid: { color: '#111827' } }
                    },
                    plugins: { legend: { labels: { color: 'var(--neon-color)' } } }
                }
            };
            pathChart = new Chart(ctx1, pathConfig);

            // 2) Histogram of counts vs Poisson(λT)
            const maxCount = Math.max(...counts);
            const labelsArr = Array.from({ length: maxCount + 1 }, (_, k) => k);
            const simProbs = labelsArr.map(k => counts.filter(x => x === k).length / m);
            const lambdaT = lambda * T;
            const theory = labelsArr.map(k => poissonPmf(k, lambdaT));

            if (countHist) countHist.destroy();
            const ctx2 = document.getElementById('countHist').getContext('2d');
            const countConfig = {
                type: 'bar',
                data: {
                    labels: labelsArr.map(String),
                    datasets: [
                        { label: 'Simulated P(N(T)=k)', data: simProbs, backgroundColor: 'rgba(0,255,194,0.6)' },
                        { label: 'Poisson(λT)', data: theory, type: 'line', borderColor: 'rgba(250,250,250,0.9)', borderWidth: 2, pointRadius: 3, fill: false }
                    ]
                },
                options: {
                    plugins: { legend: { labels: { color: 'var(--neon-color)' } } },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Probability' }, ticks: { color: 'var(--neon-color)' }, grid: { color: '#111827' } },
                        x: { ticks: { color: 'var(--neon-color)' }, grid: { color: '#111827' } }
                    }
                }
            };
            countHist = new Chart(ctx2, countConfig);

            // 3) Interarrival histogram vs exponential pdf
            const bins = 40;
            const hist = histogramDensity(interarrivals, bins);
            const centers = hist.centers;
            const densities = hist.densities; // density per unit time
            // theoretical exponential pdf at centers
            const expPdf = centers.map(x => lambda * Math.exp(-lambda * x));

            if (iaHist) iaHist.destroy();
            const ctx3 = document.getElementById('iaHist').getContext('2d');
            const iaConfig = {
                type: 'bar',
                data: {
                    labels: centers.map(c => c.toFixed(3)),
                    datasets: [
                        { label: 'Empirical density (interarrival)', data: densities, backgroundColor: 'rgba(0,120,255,0.5)' },
                        { label: 'Exponential(λ) pdf', data: expPdf, type: 'line', borderColor: 'rgba(250,250,250,0.9)', borderWidth: 2, fill: false }
                    ]
                },
                options: {
                    plugins: { legend: { labels: { color: 'var(--neon-color)' } } },
                    scales: {
                        y: { title: { display: true, text: 'Density' }, ticks: { color: 'var(--neon-color)' }, grid: { color: '#111827' } },
                        x: { ticks: { color: 'var(--neon-color)' }, grid: { color: '#111827' } }
                    }
                }
            };
            iaHist = new Chart(ctx3, iaConfig);

            // Summary
            const meanCount = counts.reduce((a,b)=>a+b,0)/counts.length;
            const varCount = counts.reduce((a,b)=>a + (b-meanCount)*(b-meanCount),0)/counts.length;
            const tv = simProbs.reduce((s,v,i)=>s + Math.abs(v - theory[i]||0), 0) * 0.5;

            document.getElementById('summary').innerHTML = `
                <div class="p-3 bg-gray-800/60 border border-gray-700">
                    <div><strong>λ</strong>: <span class="text-lime-400">${lambda}</span></div>
                    <div><strong>T</strong>: <span class="text-lime-400">${T}</span></div>
                    <div><strong>n</strong>: <span class="text-lime-400">${n}</span></div>
                    <div><strong>m</strong>: <span class="text-lime-400">${m}</span></div>
                    <div><strong>Sim time</strong>: <span class="text-cyan-400">${(t1-t0).toFixed(1)} ms</span></div>
                    <div><strong>Mean count (sim)</strong>: ${meanCount.toFixed(4)}, <strong>Var (sim)</strong>: ${varCount.toFixed(4)}</div>
                    <div><strong>Mean theoretical</strong>: ${lambdaT.toFixed(4)}, <strong>Var theoretical</strong>: ${lambdaT.toFixed(4)}</div>
                    <div><strong>Total variation (sim vs theory)</strong>: ${tv.toFixed(4)}</div>
                </div>
            `;

        });
    </script>
</body>
</html>