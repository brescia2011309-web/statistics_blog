<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Brownian motion (continuous) — Homework 11</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;200&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0d0d0d; color: #e5e7eb; }
        :root { --neon-color: #FAFAFA; --accent-color: #00FFC2; }
        .brutal-border { border: 4px solid var(--neon-color); transition: all 0.15s ease-out; }
        .brutal-border:hover { transform: translate(-3px, -3px); box-shadow: 3px 3px 0 var(--neon-color), 0 0 8px rgba(250,250,250,0.3); }
        .cyber-mono { font-family: monospace; }
        .text-neon { color: var(--neon-color); }
        .section-header { border-left: 8px solid var(--neon-color); padding-left: 1rem; margin-bottom: 1.5rem; }
        .code-block { background: #111827; padding: 1rem; border: 2px solid var(--neon-color); overflow-x: auto; }
        .cyber-input { background-color: #1f2937; color: var(--neon-color); border: 2px solid var(--neon-color); padding: 0.5rem; }
        .cyber-button { background-color: var(--neon-color); color: #0d0d0d; border: 2px solid var(--neon-color); padding: 0.5rem 1rem; font-weight:700; }
        .code-block canvas { background-color: transparent; display: block; }
    </style>
</head>
<body class="text-gray-200">
    <header class="bg-black p-6 border-b-4 border-neon">
        <div class="container mx-auto flex justify-between items-center">
            <a href="../index.html" class="text-sm font-mono tracking-wider text-neon hover:text-gray-400 transition-colors">← /MAIN_INDEX</a>
            <span class="text-sm font-mono tracking-wider text-gray-500">//BROWNIAN_MOTION</span>
        </div>
    </header>

    <main class="container mx-auto px-6 md:px-12 py-12">
        <h1 class="text-4xl font-black uppercase mb-6 text-neon cyber-mono tracking-tight">Brownian motion — continuous-time, continuous-state</h1>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Theory & background</h2>
            <p class="text-gray-300">Brownian motion (also called the Wiener process) is a continuous-time stochastic process with continuous sample paths and Gaussian increments. A standard Brownian motion B(t) satisfies B(0)=0, has independent increments, and for s<t the increment B(t)-B(s) ~ N(0, t-s). In applied settings we often simulate an arithmetic Brownian motion with drift μ and volatility σ, which has increments N(μ dt, σ^2 dt).</p>
            <p class="text-gray-300">Brownian motion is the scaling limit of random walks: if we rescale time and space appropriately, discrete random walks converge to Brownian motion (Donsker's theorem). In modeling, Brownian motion drives diffusion models, option pricing (Black–Scholes), and serves as a mathematical model for many natural random phenomena.</p>
            <p class="text-gray-300">This interactive demo simulates arithmetic Brownian motion by discretizing time into n steps over [0,T] and summing normal increments. You can choose the normal generator (Box–Muller or CLT) to observe small differences in sample quality and performance.</p>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Simulation controls</h2>

            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4">
                <div>
                    <label class="text-xs text-gray-400">Total time T</label>
                    <input id="inpT" type="number" step="0.1" min="0.01" value="1" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Steps n</label>
                    <input id="inpN" type="number" min="10" max="100000" value="500" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Paths m</label>
                    <input id="inpM" type="number" min="1" max="200" value="50" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Drift μ</label>
                    <input id="inpMu" type="number" step="0.01" value="0" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Volatility σ</label>
                    <input id="inpSigma" type="number" step="0.01" min="0" value="1" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Normal method</label>
                    <select id="method" class="cyber-input w-full">
                        <option value="boxmuller">Box–Muller</option>
                        <option value="clt">CLT (sum of uniforms)</option>
                    </select>
                </div>
                <div>
                    <label class="text-xs text-gray-400">Show sample paths</label>
                    <select id="showPaths" class="cyber-input w-full">
                        <option value="all">All paths</option>
                        <option value="first">First path only</option>
                        <option value="overlay">Overlay (thin)</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <button id="runBtn" class="cyber-button w-full">Run simulation</button>
                </div>
            </div>
            <div class="text-gray-400 text-sm">Default discretization uses increments N(μ dt, σ² dt). For large n the approximation is accurate; beware large m*n which may be slow in-browser.</div>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Visual results</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="code-block">
                    <h3 class="text-neon">Sample paths</h3>
                    <canvas id="pathsChart" height="260"></canvas>
                </div>
                <div class="code-block">
                    <h3 class="text-neon">Endpoint distribution (histogram)</h3>
                    <canvas id="endHist" height="260"></canvas>
                </div>
            </div>
            <div class="mt-4 text-sm text-gray-300" id="simInfo"></div>
            <div id="theorySummary" class="mt-4 text-gray-300">
                <h4 class="text-neon font-bold">Theoretical expectations</h4>
                <div id="theoryContent">Mean(X(T)) = μ·T, Var(X(T)) = σ²·T, Quadratic variation ≈ σ²·T. Run a simulation to compare.</div>
            </div>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Results & theoretical discussion</h2>
            <p class="text-gray-300">This section collects concise theoretical statements you can use to interpret the simulations and perform simple numerical diagnostics. The statements below are informal but state the exact distributions and asymptotic relations used as checks.</p>

            <h3 class="text-neon mt-4">1) Endpoint law (exact)</h3>
            <p class="text-gray-300">For an arithmetic Brownian motion defined by
            <code class="cyber-mono">X(t) = X(0) + μ t + σ B(t)</code> (with B a standard Wiener process and X(0)=0 here), the distribution at fixed time T is Gaussian:</p>
            <div class="code-block cyber-mono">X(T) ~ Normal( μ T,  σ^2 T )</div>
            <p class="text-gray-300">Use the sample mean and sample variance of endpoints as immediate consistency checks: the simulated <code class="cyber-mono">mean(endpoint)</code> should be close to <code class="cyber-mono">μ T</code> and <code class="cyber-mono">var(endpoint)</code> close to <code class="cyber-mono">σ^2 T</code>, with Monte Carlo error O(1/√m).</p>

            <h3 class="text-neon mt-4">2) Independent, stationary increments</h3>
            <p class="text-gray-300">Increments over disjoint intervals are independent and their law depends only on the length of the interval. For a partition 0 = t_0 < t_1 < ... < t_n = T,
            each increment ΔX_i = X(t_i) − X(t_{i-1}) is Gaussian with
            <code class="cyber-mono">ΔX_i ~ Normal( μ Δt_i, σ^2 Δt_i )</code>. Numerically you can check this by standardizing increments
            <code class="cyber-mono">(ΔX_i - μ Δt_i) / (σ √Δt_i)</code> and inspecting their empirical histogram or QQ-plot against N(0,1).</p>

            <h3 class="text-neon mt-4">3) Martingale and Markov properties</h3>
            <p class="text-gray-300">Define M(t) = X(t) − μ t. Then M(t) is a martingale (zero mean increments) and X(t) is Markov: the conditional distribution of the future given the past depends only on the current state. In practice this means that conditional forecasts from the current value are simple Gaussian shifts (useful in model checks and short-horizon predictions).</p>

            <h3 class="text-neon mt-4">4) Quadratic variation (diagnostic)</h3>
            <p class="text-gray-300">Quadratic variation over [0,T] is the limit of partition sums Σ (ΔX_i)^2 as max Δt_i → 0. For arithmetic BM,
            <div class="code-block cyber-mono">QV[0,T] = lim_{||Δ||→0} Σ_i (ΔX_i)^2 = σ^2 T.</div>
            Numerically the Riemann sum Σ (ΔX_i)^2 computed on the simulation should be approximately σ^2 T (error decreases as n increases). This gives a robust check of discretization fidelity and the chosen σ.</p>

            <h3 class="text-neon mt-4">5) Convergence and scaling remarks</h3>
            <p class="text-gray-300">If you construct Brownian motion as a scaling limit of simple symmetric random walks, Donsker's invariance principle formalizes that the rescaled path distribution converges (in distribution in Skorokhod space) to Wiener measure. For our Gaussian-increment discrete construction the marginal increment law is already exact; discretization error manifests mostly in pathwise functionals (e.g., sup-norm, local time) and decreases as Δt→0. Typical pointwise errors scale like O(√Δt) for increments.</p>

            <h3 class="text-neon mt-4">6) RNG method: Box–Muller vs CLT</h3>
            <p class="text-gray-300">Box–Muller transforms two independent uniforms to two exact standard normals (given the underlying uniform RNG) and preserves tail accuracy; the CLT-sum-of-12-uniforms is only an approximation (faster but with inferior tail behavior). Use Box–Muller when endpoint tails, extreme quantiles, or quadratic-variation diagnostics are important. CLT is acceptable for quick, visually plausible demos.</p>

            <h3 class="text-neon mt-4">7) Practical numerical checks (what to compute)</h3>
            <ul class="ml-6 text-gray-300 mt-3">
                <li>Compare simulated <code class="cyber-mono">mean(endpoint)</code> and <code class="cyber-mono">var(endpoint)</code> to theoretical <code class="cyber-mono">μ T</code> and <code class="cyber-mono">σ^2 T</code> (report relative error; Monte Carlo standard error ≈ √(Var/ m)).</li>
                <li>Overlay the theoretical Normal(μ T, σ^2 T) pdf on the endpoint histogram (I can add a toggle for this overlay).</li>
                <li>Standardize increments and produce a QQ-plot / histogram versus N(0,1) to check Gaussianity of increments.</li>
                <li>Compute quadratic variation Σ (ΔX_i)^2 for a few sample paths and compare to σ^2 T; plot the distribution across simulated paths.</li>
                <li>Compare results using <code class="cyber-mono">boxmuller</code> and <code class="cyber-mono">clt</code> RNG methods to inspect tail differences and runtime.</li>
            </ul>

            <p class="text-gray-300 mt-3">If you want, I can implement the overlay of the Normal pdf on the histogram, add a small table that reports quadratic-variation per path, and produce QQ-plots in-page. Tell me which diagnostics you prefer and I will add them.</p>
        </section>

    </main>

    <script>
        // Keep the same simulation code but adjust Chart defaults for dark theme
        (function(){
            try{
                Chart.defaults.color = 'var(--neon-color)';
                Chart.defaults.font.family = "'Inter', sans-serif";
                Chart.defaults.elements.line.borderColor = 'rgba(250,250,250,0.9)';
                Chart.defaults.plugins.legend.labels.color = 'var(--neon-color)';
            }catch(e){console.warn(e)}
        })();

        // Box-Muller
        function boxMuller(){ const u1=Math.random(); const u2=Math.random(); const r=Math.sqrt(-2*Math.log(u1)); const theta=2*Math.PI*u2; return r*Math.cos(theta); }
        // CLT approx
        function normalCLT(){ let s=0; for(let i=0;i<12;i++) s+=Math.random(); return s-6; }
        function genStandardNormal(method){ return method==='boxmuller'?boxMuller():normalCLT(); }

        function simulateBM(n,T,mu,sigma,m,method){
            const dt = T/n; const sqrtDt = Math.sqrt(dt);
            const times = new Array(n+1); for(let i=0;i<=n;i++) times[i]=(i*dt).toFixed(4);
            const paths=[]; const endpoints=[];
            for(let j=0;j<m;j++){
                const x=new Array(n+1); x[0]=0;
                for(let i=1;i<=n;i++){ const z=genStandardNormal(method); const inc = mu*dt + sigma*sqrtDt*z; x[i]=x[i-1]+inc; }
                paths.push(x); endpoints.push(x[n]);
            }
            return {times,paths,endpoints};
        }

        function histogram(data,bins=30){ const min=Math.min(...data); const max=Math.max(...data); const width=(max-min)/bins||1; const counts=new Array(bins).fill(0); const centers=new Array(bins); for(let i=0;i<bins;i++) centers[i]=(min+(i+0.5)*width).toFixed(4); data.forEach(v=>{ const idx=Math.min(Math.floor((v-min)/width),bins-1); counts[idx]++; }); return {centers,counts}; }

        const pathsCtx = document.getElementById('pathsChart').getContext('2d');
        const endCtx = document.getElementById('endHist').getContext('2d');
        let pathsChart=null, endChart=null;

        function draw(pathsData, showOption){
            const {times,paths,endpoints}=pathsData; const ds=[]; const m=paths.length;
            for(let j=0;j<m;j++){ const label='path '+(j+1); const color=`hsl(${(j*360/m)%360} 90% 60%)`; const thin = showOption==='overlay'; if(showOption==='first' && j>0) break; ds.push({ label, data: paths[j].map((v,i)=>({x:parseFloat(times[i]), y:v})), borderColor: color, borderWidth: thin?0.8:1.8, pointRadius:0, tension:0.12 }); }
            if(pathsChart) pathsChart.destroy(); pathsChart = new Chart(pathsCtx, { type:'line', data:{datasets:ds}, options:{ parsing:false, scales:{ x:{type:'linear', title:{display:true, text:'time'}}, y:{title:{display:true, text:'value'}} }, plugins:{ legend:{ display:false } } } });
            const {centers,counts} = histogram(endpoints, Math.min(40, Math.max(10, Math.floor(Math.sqrt(endpoints.length)*2))));
            if(endChart) endChart.destroy(); endChart = new Chart(endCtx, { type:'bar', data:{ labels:centers, datasets:[{ label:'endpoint counts', data:counts, backgroundColor:'rgba(250,250,250,0.08)' }] }, options:{ scales:{ x:{ title:{ display:true, text:'endpoint value' } }, y:{ title:{ display:true, text:'count' } } }, plugins:{ legend:{ display:false } } } });
        }

        document.getElementById('runBtn').addEventListener('click', ()=>{
            const T = parseFloat(document.getElementById('inpT').value) || 1;
            const n = parseInt(document.getElementById('inpN').value) || 500;
            const m = parseInt(document.getElementById('inpM').value) || 50;
            const mu = parseFloat(document.getElementById('inpMu').value) || 0;
            const sigma = parseFloat(document.getElementById('inpSigma').value) || 1;
            const method = document.getElementById('method').value;
            const show = document.getElementById('showPaths').value;
            // safety cap
            const MAX = 20000000; if(m*n > MAX && !confirm('Large m*n may be slow. Continue?')) return;
            const t0 = performance.now();
            const data = simulateBM(n,T,mu,sigma,m,method);
            const dt = T/n;
            const meanEndpoint = data.endpoints.reduce((a,b)=>a+b,0)/data.endpoints.length;
            const varEndpoint = data.endpoints.reduce((a,b)=>a+(b-meanEndpoint)**2,0)/data.endpoints.length;
            const elapsed = ((performance.now()-t0)/1000).toFixed(3);
            document.getElementById('simInfo').innerText = `m=${m}, n=${n}, T=${T}, dt=${dt.toFixed(5)}, method=${method}, elapsed=${elapsed}s — mean(endpoint)=${meanEndpoint.toFixed(4)}, var(endpoint)=${varEndpoint.toFixed(4)}`;
            // Theoretical values and relative errors
            const theoMean = mu * T;
            const theoVar = (sigma * sigma) * T;
            const meanErr = (theoMean === 0) ? (meanEndpoint - theoMean) : ( (meanEndpoint - theoMean) / Math.abs(theoMean) );
            const varErr = (theoVar === 0) ? (varEndpoint - theoVar) : ( (varEndpoint - theoVar) / Math.abs(theoVar) );
            // Quadratic variation estimate for the first path (as diagnostic)
            const qvPerPath = data.paths.map(path=>{
                let s=0; for(let i=1;i<path.length;i++){ const d=path[i]-path[i-1]; s += d*d; } return s;
            });
            const avgQV = qvPerPath.reduce((a,b)=>a+b,0)/qvPerPath.length;
            const theoQV = theoVar; // equals sigma^2 * T
            const qvErr = (theoQV === 0) ? (avgQV - theoQV) : ( (avgQV - theoQV) / Math.abs(theoQV) );
            const theoryContent = `Theoretical: mean = ${theoMean.toFixed(4)}, var = ${theoVar.toFixed(4)}, QV = ${theoQV.toFixed(4)}.\n` +
                `Simulated: mean = ${meanEndpoint.toFixed(4)} (rel err ${ (meanErr*100).toFixed(2) }%), var = ${varEndpoint.toFixed(4)} (rel err ${ (varErr*100).toFixed(2) }%), avg QV = ${avgQV.toFixed(4)} (rel err ${ (qvErr*100).toFixed(2) }%).`;
            document.getElementById('theoryContent').innerText = theoryContent;
            draw(data, show);
        });

    </script>
    <!-- Saved on 2025-11-28 by assistant: re-saved to ensure latest changes are recorded -->
</body>
</html>
