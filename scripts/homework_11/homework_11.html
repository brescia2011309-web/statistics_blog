<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Brownian motion (continuous) — Homework 11</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;200&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0d0d0d; color: #e5e7eb; }
        :root { --neon-color: #FAFAFA; --accent-color: #00FFC2; }
        .brutal-border { border: 4px solid var(--neon-color); transition: all 0.15s ease-out; }
        .brutal-border:hover { transform: translate(-3px, -3px); box-shadow: 3px 3px 0 var(--neon-color), 0 0 8px rgba(250,250,250,0.3); }
        .cyber-mono { font-family: monospace; }
        .text-neon { color: var(--neon-color); }
        .section-header { border-left: 8px solid var(--neon-color); padding-left: 1rem; margin-bottom: 1.5rem; }
        .code-block { background: #111827; padding: 1rem; border: 2px solid var(--neon-color); overflow-x: auto; }
        .cyber-input { background-color: #1f2937; color: var(--neon-color); border: 2px solid var(--neon-color); padding: 0.5rem; }
        .cyber-button { background-color: var(--neon-color); color: #0d0d0d; border: 2px solid var(--neon-color); padding: 0.5rem 1rem; font-weight:700; }
        .code-block canvas { background-color: transparent; display: block; }
    </style>
</head>
<body class="text-gray-200">
    <header class="bg-black p-6 border-b-4 border-neon">
        <div class="container mx-auto flex justify-between items-center">
            <a href="../index.html" class="text-sm font-mono tracking-wider text-neon hover:text-gray-400 transition-colors">← /MAIN_INDEX</a>
            <span class="text-sm font-mono tracking-wider text-gray-500">//BROWNIAN_MOTION</span>
        </div>
    </header>

    <main class="container mx-auto px-6 md:px-12 py-12">
        <h1 class="text-4xl font-black uppercase mb-6 text-neon cyber-mono tracking-tight">Brownian motion — continuous-time, continuous-state</h1>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Theory & background</h2>
            <p class="text-gray-300">Brownian motion (also called the Wiener process) is a continuous-time stochastic process with continuous sample paths and Gaussian increments. A standard Brownian motion B(t) satisfies B(0)=0, has independent increments, and for s<t the increment B(t)-B(s) ~ N(0, t-s). In applied settings we often simulate an arithmetic Brownian motion with drift μ and volatility σ, which has increments N(μ dt, σ^2 dt).</p>
            <p class="text-gray-300">Brownian motion is the scaling limit of random walks: if we rescale time and space appropriately, discrete random walks converge to Brownian motion (Donsker's theorem). In modeling, Brownian motion drives diffusion models, option pricing (Black–Scholes), and serves as a mathematical model for many natural random phenomena.</p>
            <p class="text-gray-300">This interactive demo simulates arithmetic Brownian motion by discretizing time into n steps over [0,T] and summing normal increments. You can choose the normal generator (Box–Muller or CLT) to observe small differences in sample quality and performance.</p>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Simulation controls</h2>

            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4">
                <div>
                    <label class="text-xs text-gray-400">Total time T</label>
                    <input id="inpT" type="number" step="0.1" min="0.01" value="1" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Steps n</label>
                    <input id="inpN" type="number" min="10" max="100000" value="500" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Paths m</label>
                    <input id="inpM" type="number" min="1" max="200" value="50" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Drift μ</label>
                    <input id="inpMu" type="number" step="0.01" value="0" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Volatility σ</label>
                    <input id="inpSigma" type="number" step="0.01" min="0" value="1" class="cyber-input w-full" />
                </div>
                <div>
                    <label class="text-xs text-gray-400">Normal method</label>
                    <select id="method" class="cyber-input w-full">
                        <option value="boxmuller">Box–Muller</option>
                        <option value="clt">CLT (sum of uniforms)</option>
                    </select>
                </div>
                <div>
                    <label class="text-xs text-gray-400">Show sample paths</label>
                    <select id="showPaths" class="cyber-input w-full">
                        <option value="all">All paths</option>
                        <option value="first">First path only</option>
                        <option value="overlay">Overlay (thin)</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <button id="runBtn" class="cyber-button w-full">Run simulation</button>
                </div>
            </div>
            <div class="text-gray-400 text-sm">Default discretization uses increments N(μ dt, σ² dt). For large n the approximation is accurate; beware large m*n which may be slow in-browser.</div>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Visual results</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="code-block">
                    <h3 class="text-neon">Sample paths</h3>
                    <canvas id="pathsChart" height="260"></canvas>
                </div>
                <div class="code-block">
                    <h3 class="text-neon">Endpoint distribution (histogram)</h3>
                    <canvas id="endHist" height="260"></canvas>
                </div>
            </div>
            <div class="mt-4 text-sm text-gray-300" id="simInfo"></div>
            <div id="theorySummary" class="mt-4 text-gray-300">
                <h4 class="text-neon font-bold">Theoretical expectations</h4>
                <div id="theoryContent">Mean(X(T)) = μ·T, Var(X(T)) = σ²·T, Quadratic variation ≈ σ²·T. Run a simulation to compare.</div>
            </div>
        </section>

        <section class="mb-6 p-6 bg-gray-900/50 brutal-border">
            <h2 class="text-2xl font-bold text-neon section-header cyber-mono">Interpretation of visual results</h2>
            

            <h3 class="text-neon mt-4">Sample paths</h3>
            <p class="text-gray-300">- Overall drift: a visible upward or downward trend across most paths indicates nonzero drift μ. If paths cluster around a rising line, drift dominates short-term noise.<br>
            - Volatility: the vertical spread and roughness of paths reflect σ. Larger σ produces wider, more oscillatory trajectories. Compare path envelopes visually to judge relative volatility.<br>
            - Path-to-path variability: different realizations show how much randomness affects individual trajectories; if m is small, expect large sampling variability.</p>

            <h3 class="text-neon mt-4">Endpoint histogram</h3>
            <p class="text-gray-300">- Center and spread: the histogram center approximates the simulated mean at time T; its spread approximates the standard deviation ≈ σ√T. A bell-shaped histogram centered near the displayed theoretical mean indicates the simulation is behaving as expected.<br>
            - Tails and outliers: heavy-looking tails or isolated bars far from the center may indicate sampling variability (small m), RNG tail differences (CLT vs Box–Muller), or insufficient binning. Use more paths or Box–Muller for tail-sensitive checks.</p>

            <h3 class="text-neon mt-4">Practical checks shown on the page</h3>
            <p class="text-gray-300">- The line labeled in the control panel reports simulated mean, variance and an average quadratic-variation estimate. Small relative errors (a few percent or less for moderate m) indicate good agreement; large errors suggest increasing m or reducing dt.<br>
            - If the histogram looks skewed or the sample mean is far from μ·T, re-run with larger m or verify inputs (μ, σ, T) are correct.</p>

            
        </section>

    </main>

    <script>
        // Keep the same simulation code but adjust Chart defaults for dark theme
        (function(){
            try{
                Chart.defaults.color = 'var(--neon-color)';
                Chart.defaults.font.family = "'Inter', sans-serif";
                Chart.defaults.elements.line.borderColor = 'rgba(250,250,250,0.9)';
                Chart.defaults.plugins.legend.labels.color = 'var(--neon-color)';
            }catch(e){console.warn(e)}
        })();

        // Box-Muller
        function boxMuller(){ const u1=Math.random(); const u2=Math.random(); const r=Math.sqrt(-2*Math.log(u1)); const theta=2*Math.PI*u2; return r*Math.cos(theta); }
        // CLT approx
        function normalCLT(){ let s=0; for(let i=0;i<12;i++) s+=Math.random(); return s-6; }
        function genStandardNormal(method){ return method==='boxmuller'?boxMuller():normalCLT(); }

        function simulateBM(n,T,mu,sigma,m,method){
            const dt = T/n; const sqrtDt = Math.sqrt(dt);
            const times = new Array(n+1); for(let i=0;i<=n;i++) times[i]=(i*dt).toFixed(4);
            const paths=[]; const endpoints=[];
            for(let j=0;j<m;j++){
                const x=new Array(n+1); x[0]=0;
                for(let i=1;i<=n;i++){ const z=genStandardNormal(method); const inc = mu*dt + sigma*sqrtDt*z; x[i]=x[i-1]+inc; }
                paths.push(x); endpoints.push(x[n]);
            }
            return {times,paths,endpoints};
        }

        function histogram(data,bins=30){ const min=Math.min(...data); const max=Math.max(...data); const width=(max-min)/bins||1; const counts=new Array(bins).fill(0); const centers=new Array(bins); for(let i=0;i<bins;i++) centers[i]=(min+(i+0.5)*width).toFixed(4); data.forEach(v=>{ const idx=Math.min(Math.floor((v-min)/width),bins-1); counts[idx]++; }); return {centers,counts}; }

        const pathsCtx = document.getElementById('pathsChart').getContext('2d');
        const endCtx = document.getElementById('endHist').getContext('2d');
        let pathsChart=null, endChart=null;

        function draw(pathsData, showOption){
            const {times,paths,endpoints}=pathsData; const ds=[]; const m=paths.length;
            for(let j=0;j<m;j++){ const label='path '+(j+1); const color=`hsl(${(j*360/m)%360} 90% 60%)`; const thin = showOption==='overlay'; if(showOption==='first' && j>0) break; ds.push({ label, data: paths[j].map((v,i)=>({x:parseFloat(times[i]), y:v})), borderColor: color, borderWidth: thin?0.8:1.8, pointRadius:0, tension:0.12 }); }
            if(pathsChart) pathsChart.destroy(); pathsChart = new Chart(pathsCtx, { type:'line', data:{datasets:ds}, options:{ parsing:false, scales:{ x:{type:'linear', title:{display:true, text:'time'}}, y:{title:{display:true, text:'value'}} }, plugins:{ legend:{ display:false } } } });
            const {centers,counts} = histogram(endpoints, Math.min(40, Math.max(10, Math.floor(Math.sqrt(endpoints.length)*2))));
            if(endChart) endChart.destroy(); endChart = new Chart(endCtx, { type:'bar', data:{ labels:centers, datasets:[{ label:'endpoint counts', data:counts, backgroundColor:'rgba(250,250,250,0.08)' }] }, options:{ scales:{ x:{ title:{ display:true, text:'endpoint value' } }, y:{ title:{ display:true, text:'count' } } }, plugins:{ legend:{ display:false } } } });
        }

        document.getElementById('runBtn').addEventListener('click', ()=>{
            const T = parseFloat(document.getElementById('inpT').value) || 1;
            const n = parseInt(document.getElementById('inpN').value) || 500;
            const m = parseInt(document.getElementById('inpM').value) || 50;
            const mu = parseFloat(document.getElementById('inpMu').value) || 0;
            const sigma = parseFloat(document.getElementById('inpSigma').value) || 1;
            const method = document.getElementById('method').value;
            const show = document.getElementById('showPaths').value;
            // safety cap
            const MAX = 20000000; if(m*n > MAX && !confirm('Large m*n may be slow. Continue?')) return;
            const t0 = performance.now();
            const data = simulateBM(n,T,mu,sigma,m,method);
            const dt = T/n;
            const meanEndpoint = data.endpoints.reduce((a,b)=>a+b,0)/data.endpoints.length;
            const varEndpoint = data.endpoints.reduce((a,b)=>a+(b-meanEndpoint)**2,0)/data.endpoints.length;
            const elapsed = ((performance.now()-t0)/1000).toFixed(3);
            document.getElementById('simInfo').innerText = `m=${m}, n=${n}, T=${T}, dt=${dt.toFixed(5)}, method=${method}, elapsed=${elapsed}s — mean(endpoint)=${meanEndpoint.toFixed(4)}, var(endpoint)=${varEndpoint.toFixed(4)}`;
            // Theoretical values and relative errors
            const theoMean = mu * T;
            const theoVar = (sigma * sigma) * T;
            const meanErr = (theoMean === 0) ? (meanEndpoint - theoMean) : ( (meanEndpoint - theoMean) / Math.abs(theoMean) );
            const varErr = (theoVar === 0) ? (varEndpoint - theoVar) : ( (varEndpoint - theoVar) / Math.abs(theoVar) );
            // Quadratic variation estimate for the first path (as diagnostic)
            const qvPerPath = data.paths.map(path=>{
                let s=0; for(let i=1;i<path.length;i++){ const d=path[i]-path[i-1]; s += d*d; } return s;
            });
            const avgQV = qvPerPath.reduce((a,b)=>a+b,0)/qvPerPath.length;
            const theoQV = theoVar; // equals sigma^2 * T
            const qvErr = (theoQV === 0) ? (avgQV - theoQV) : ( (avgQV - theoQV) / Math.abs(theoQV) );
            const theoryContent = `Theoretical: mean = ${theoMean.toFixed(4)}, var = ${theoVar.toFixed(4)}, QV = ${theoQV.toFixed(4)}.\n` +
                `Simulated: mean = ${meanEndpoint.toFixed(4)} (rel err ${ (meanErr*100).toFixed(2) }%), var = ${varEndpoint.toFixed(4)} (rel err ${ (varErr*100).toFixed(2) }%), avg QV = ${avgQV.toFixed(4)} (rel err ${ (qvErr*100).toFixed(2) }%).`;
            document.getElementById('theoryContent').innerText = theoryContent;
            draw(data, show);
        });

    </script>
    <!-- Saved on 2025-11-28 by assistant: re-saved to ensure latest changes are recorded -->
</body>
</html>
