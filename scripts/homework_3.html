<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 3 - Cryptography and Statistics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js for visualization in the LLN section -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        /* Import e Stili di Base */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;200&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            /* Sfondo ultra-scuro */
            background-color: #0d0d0d; 
            color: #e5e7eb; /* Testo grigio chiaro */
        }
        
        /* Colore Neon Accento (BIANCO/GRIGIO DIGITALE per Cybersigilism) */
        :root {
            --neon-color: #FAFAFA; 
            --dark-border: #1f2937;
            --accent-color: #00FFC2; /* A secondary, stark neon green for LLN */
        }

        /* Stili Brutalisti + Sigil Effect per i Box */
        .brutal-border {
            border: 4px solid var(--neon-color); 
            transition: all 0.15s ease-out;
        }
        .brutal-border:hover {
            transform: translate(-3px, -3px);
            box-shadow: 3px 3px 0 var(--neon-color), 0 0 8px rgba(250, 250, 250, 0.3); 
        }
        
        /* Glow e Monospace per elementi tecnici/importanti */
        .cyber-mono {
            font-family: monospace;
        }
        .cyber-glow-text {
            text-shadow: 0 0 5px rgba(250, 250, 250, 0.4);
        }
        .text-neon {
            color: var(--neon-color);
        }
        
        /* Stile per le intestazioni di Sezione (H3) */
        .section-header {
            border-left: 8px solid var(--neon-color);
            padding-left: 1rem;
            margin-bottom: 1.5rem;
            line-height: 1.2;
        }

        /* Stile per i blocchi di Codice/Definizione */
        .code-block-brutal {
            background-color: #1f2937; /* Grigio scuro/nero per lo sfondo del codice */
            border: 2px solid var(--neon-color);
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            overflow-x: auto;
        }

        /* Nuovo stile per le formule all'interno del codice block, per centrarle */
        .formula {
            display: block;
            text-align: center;
            font-size: 1.5rem; /* Rende la formula più visibile */
            padding: 0.5rem 0;
            color: #fff;
            white-space: nowrap; /* Evita interruzioni di riga */
        }

        /* Custom style for LLN inputs/buttons to fit theme */
        .cyber-input {
            background-color: #1f2937;
            color: var(--neon-color);
            border: 2px solid var(--neon-color);
            padding: 0.5rem;
        }
        .cyber-button {
            background-color: var(--neon-color);
            color: #0d0d0d;
            border: 2px solid var(--neon-color);
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.1s;
        }
        .cyber-button:hover {
            background-color: #0d0d0d;
            color: var(--neon-color);
            box-shadow: 0 0 8px rgba(250, 250, 250, 0.5);
        }
    </style>
</head>
<body class="text-gray-200">

    <header class="bg-black p-6 border-b-4 border-neon">
        <div class="container mx-auto flex justify-between items-center">
            <a href="#" class="text-sm font-mono tracking-wider text-neon hover:text-gray-400 transition-colors">
                ← /MAIN_INDEX
            </a>
            <span class="text-sm font-mono tracking-wider text-gray-500">
                //HOMEWORK_03
            </span>
        </div>
    </header>

    <main class="container mx-auto px-6 md:px-12 py-12">
        
        <h1 class="text-5xl sm:text-6xl font-black uppercase mb-4 text-neon cyber-glow-text cyber-mono tracking-tight">
            ALGORITHM &amp; ANALYSIS
        </h1>
        
        <p class="text-lg font-mono mb-10 text-gray-500 border-b-2 border-gray-700 pb-4">
            CRYPTOGRAPHY + STATISTICAL VALIDATION
        </p>

        <!-- INTRODUZIONE / ABSTRACT -->
        <section class="mb-12 p-6 bg-gray-900/50 brutal-border">
            <p class="text-lg leading-relaxed text-gray-300">
                This document explores two fundamental concepts: the **RSA** algorithm, the cornerstone of public-key cryptography, and the **Law of Large Numbers (LLN)**, a key principle of statistical probability. The RSA section demonstrates the mathematics of public/private key generation, while the LLN section provides a runnable simulation to empirically confirm the long-term stability of probability theory.
            </p>
        </section>

        <!-- === [ SECTION 1: RSA ALGORITHM ] === -->
        <h2 class="text-4xl font-black uppercase mb-6 text-neon cyber-mono section-header">
            [01] RSA ALGORITHM
        </h2>
        
        <!-- SECTION 1.1: Key Pair Generation Theory -->
        <h3 class="text-3xl font-bold uppercase text-neon section-header">
            [01.1] GENERATING THE KEY PAIR
        </h3>
        
        <p class="text-lg leading-relaxed mb-6">
            RSA security begins with the choice of two enormous, random prime numbers, <span class="cyber-mono">p</span> and <span class="cyber-mono">q</span>. These numbers are used to generate the public modulus <span class="cyber-mono">N</span> and the two keys, public and private.
        </p>

        <ul class="list-none space-y-4 mb-8 text-gray-300">
            <li class="bg-gray-800 p-3 rounded-md border-l-4 border-lime-400 shadow-lg">
                <span class="font-bold text-lime-400">STEP 1: Modulus</span>
                <span class="cyber-mono ml-4 text-gray-400">// Public Base</span><br>
                <span class="formula cyber-mono">N = p &middot; q</span>
            </li>
            <li class="bg-gray-800 p-3 rounded-md border-l-4 border-yellow-400 shadow-lg">
                <span class="font-bold text-yellow-400">STEP 2: Euler's Totient (φ(N))</span>
                <span class="cyber-mono ml-4 text-gray-400">// Required for Private Key</span><br>
                <span class="formula cyber-mono">φ(N) = (p - 1) &middot; (q - 1)</span>
            </li>
            <li class="bg-gray-800 p-3 rounded-md border-l-4 border-cyan-400 shadow-lg">
                <span class="font-bold text-cyan-400">STEP 3: Public Exponent (e)</span>
                <span class="cyber-mono ml-4 text-gray-400">// Must be $1 < e < \phi(N)$ and $\text{gcd}(e, \phi(N))=1$</span>
            </li>
            <li class="bg-gray-800 p-3 rounded-md border-l-4 border-red-400 shadow-lg">
                <span class="font-bold text-red-400">STEP 4: Private Exponent (d)</span>
                <span class="cyber-mono ml-4 text-gray-400">// Multiplicative Inverse of $e \pmod{\phi(N)}$</span><br>
                <span class="formula cyber-mono">d &middot; e \equiv 1 \pmod{\phi(N)}</span>
            </li>
        </ul>
        
        <div class="p-4 bg-gray-900/70 border-l-8 border-gray-500 mb-10">
            <p class="font-mono text-base text-gray-400">
                **Public Key (Encrypt)**: \{e, N\}<br>
                **Private Key (Decrypt)**: \{d, N\}
            </p>
        </div>

        <!-- SECTION 1.2: RSA Demo -->
        <section id="rsa-demo" class="mb-12 p-6 bg-gray-900/50 brutal-border">
            <h3 class="text-2xl font-bold uppercase text-neon section-header cyber-mono">
                [01.2] DEMO: ENCRYPT &amp; VERIFY WITH ITALIAN DISTRIBUTION
            </h3>

            <p class="text-base leading-relaxed text-gray-400 mb-4">
                This demo uses very small primes (educational only). The script will: normalize a passage, encode it in base-26 blocks, encrypt with RSA, then factor the modulus, recover the private key, decrypt, and compute a chi-squared score against approximate Italian letter frequencies to verify the result.
            </p>

            <!-- Hidden passage -->
            <script id="demo-passage" type="text/plain" style="display:none">
Lunedí 13 settembre. Les Salines. È uno scenario piuttosto straordinario quest’
abbozzo di città abbandonata ai bordi di un villaggio e al margine dei secoli. Ho percorso una metà
dell’emiciclo, ho salito la gradinata del padiglione centrale, e per un pezzo
sono rimasta a contemplare questi edifici costruiti per fini utilitari e che non
sono mai serviti a niente. Sono solidi, esistono, eppure il fatto di essere
abbandonati li trasforma in un simulacro fantastico; di che cosa, non si sa.
L’erba calda, sotto il cielo d’autunno, e l’odore delle foglie morte
m’assicuravano che non avevo lasciato questo mondo, ma ero tornata
indietro, nel passato, di duecento anni. Sono andata a prendere della roba
nella macchina; ho steso in terra una coperta, vi ho posato dei cuscini, la radio
a transistor, e mi sono messa a fumare, ascoltando Mozart. Dietro due o tre
finestre polverose indovinavo delle presenze: sono sicuramente uffici. Un
camion si è fermato davanti a uno dei pesanti portoni, alcuni uomini l'hanno
aperto, hanno caricato dei sacchi nel cassone. Nient’altro ha turbato il silenzio
di questo pomeriggio: nessun visitatore. Finito il concerto, mi son messa a
leggere. Mi sentivo doppiamente spaesata: me ne andavo lontano, lungo la
riva di un fiume sconosciuto: alzavo gli occhi, e mi ritrovavo in mezzo a
queste pietre, lontana dalla mia vita.
Poiché la cosa piú sorprendente è la mia presenza qui, e il fatto che mi
senta cosí allegra. Temevo la solitudine di questo ritorno verso Parigi. Finora,
quando non c’è Maurice, le bambine mi accompagnavano in tutti i miei
viaggi. Pensavo che avrei sentito la mancanza dei rapimenti di Colette, delle
esigenze di Lucienne. E invece, ecco che provo un tipo di gioia che avevo del
tutto dimenticato. Un senso di libertà che mi ringiovanisce di vent’anni. Al punto che, chiuso il libro, mi sono messa a scrivere, per me stessa, come a
vent’anni.
Ogni volta che mi separo da Maurice, non è mai a cuor leggero. Il
congresso dura appena una settimana, eppure, mentre andavamo da Mougins
            </script>

            <div id="status" class="text-sm text-lime-400 cyber-mono mb-2">Processing...</div>
            <div id="rsa-output" class="p-4 bg-gray-900/40 brutal-border text-sm cyber-mono"></div>

            <script>
                // --- RSA Utility Functions ---

                // Helper to remove diacritics and non-alpha chars
                function normalize(text){
                    try{ text = text.normalize('NFKD').replace(/\p{Diacritic}/gu,''); } catch(e){}
                    return text.toLowerCase().replace(/[^a-z]/g,'');
                }

                // Encodes pairs of letters into a single number (M = a*26 + b)
                function encodePairs(s){
                    if(s.length % 2 === 1) s += 'x';
                    const out = [];
                    for(let i=0;i<s.length;i+=2){
                        const a = s.charCodeAt(i)-97;
                        const b = s.charCodeAt(i+1)-97;
                        out.push(a*26 + b);
                    }
                    return out;
                }

                // Decodes a single number back into two letters
                function decodePairs(blocks){
                    let o = '';
                    for(const v of blocks){
                        const a = Math.floor(v/26);
                        const b = v % 26;
                        o += String.fromCharCode(a+97) + String.fromCharCode(b+97);
                    }
                    return o;
                }

                // Extended Euclidean Algorithm (egcd)
                function egcd(a,b){
                    if(b===0) return [a,1,0];
                    const r = egcd(b, a%b);
                    return [r[0], r[2], r[1] - Math.floor(a/b)*r[2]];
                }
                
                // Modular Inverse
                function modinv(a,m){
                    const r = egcd(a,m);
                    if(r[0] !== 1) { console.error('No modular inverse found'); return 0; }
                    return (r[1]%m + m) % m;
                }

                // Trial factor small n (only for educational demo)
                function factorSmall(n){
                    for(let i=2;i<=Math.floor(Math.sqrt(n));i++) if(n%i===0) return [i, n/i];
                    return null;
                }

                // Modular Exponentiation (base^exp mod mod)
                function powmod(base, exp, mod){
                    let res = 1;
                    base = base % mod;
                    while(exp > 0){
                        if(exp & 1) res = (res * base) % mod;
                        base = (base * base) % mod;
                        exp = Math.floor(exp/2);
                    }
                    return res;
                }

                // Frequency counter (returns frequency map)
                function freq(s){
                    const cnt = {};
                    for(const ch of s) cnt[ch] = (cnt[ch]||0)+1;
                    const n = s.length || 1;
                    const out = {};
                    for(let i=0;i<26;i++){
                        const ch = String.fromCharCode(97+i);
                        out[ch] = (cnt[ch]||0)/n;
                    }
                    return out;
                }

                // Chi-squared test against expected frequencies
                function chi2(obs, exp){
                    let s = 0;
                    const N = Object.keys(obs).reduce((sum, key) => sum + obs[key], 0) || 1;
                    for(let i=0; i<26; i++){
                        const ch = String.fromCharCode(97+i);
                        const observed_count = (obs[ch] || 0) * N;
                        const expected_freq = exp[ch] || 1e-6; // Use tiny non-zero default for rare letters
                        const expected_count = expected_freq * N;
                        
                        if (expected_count > 0) {
                            s += Math.pow(observed_count - expected_count, 2) / expected_count;
                        }
                    }
                    return s;
                }

                // Approximate Italian expected frequencies (normalized to 1)
                const italian_expected_raw = {a:11.7,b:1.2,c:4.9,d:3.7,e:11.8,f:1.0,g:1.7,h:0.7,i:10.6,j:0.01,k:0.01,l:6.5,m:2.5,n:6.7,o:9.8,p:3.5,q:0.9,r:6.3,s:4.9,t:5.6,u:3.1,v:2.3,w:0.01,x:0.01,y:0.01,z:1.2};
                const total = Object.values(italian_expected_raw).reduce((a, b) => a + b, 0);
                const italian_expected = Object.keys(italian_expected_raw).reduce((acc, key) => {
                    acc[key] = italian_expected_raw[key] / total;
                    return acc;
                }, {});


                // Function to render bar chart (used by RSA demo)
                function renderCounts(containerId, counts, title, primaryColor = 'var(--neon-color)'){
                    const chart = document.getElementById(containerId);
                    chart.innerHTML = '';
                    
                    const letters = [];
                    for(let i=0;i<26;i++) letters.push(String.fromCharCode(97+i));
                    
                    const maxCount = Math.max(...Object.values(counts), 1);
                    const totalCount = Object.values(counts).reduce((a, b) => a + b, 0) || 1;

                    // Add title
                    chart.innerHTML += `<div class="text-xs font-bold uppercase mb-2 text-gray-400">${title} (Total: ${totalCount})</div>`;

                    for(const l of letters){
                        const c = counts[l] || 0;
                        const pct_width = Math.round((c / maxCount) * 100);
                        const pct_text = ((c / totalCount) * 100).toFixed(2);
                        
                        const row = document.createElement('div');
                        row.className = 'flex items-center my-1 text-xs';
                        row.innerHTML = `<div class="lf-label w-4 text-neon">${l}</div>` +
                                        `<div class="lf-bar flex-grow h-4 bg-gray-800 border border-gray-700">` +
                                            `<div class="h-full" style="width:${pct_width}%; background-color:${primaryColor};"></div>` +
                                        `</div>` +
                                        `<div class="w-12 text-right text-gray-400">${pct_text}%</div>`;
                        chart.appendChild(row);
                    }
                }

                // --- Main RSA Demo Runner ---
                function runRsaDemo(){
                    const raw = document.getElementById('demo-passage').textContent || '';
                    const s = normalize(raw);
                    const blocks = encodePairs(s);

                    // Small RSA Parameters (for educational demo where N is easily factorable)
                    const p = 61, q = 53;
                    const n = p*q; // 3233
                    const phi = (p-1)*(q-1); // 60 * 52 = 3120
                    const e = 17; // Common public exponent
                    const d = modinv(e, phi); // Private exponent (2753 in this case)

                    if (d === 0) {
                        const statusEl = document.getElementById('status');
                        if(statusEl) statusEl.textContent = 'Error: No modular inverse for d found. Check GCD(e, phi).';
                        return;
                    }

                    // Encryption: C = M^e mod N
                    const cipher = blocks.map(m => powmod(m, e, n));

                    // Attacker factors N to get p, q
                    const factors = factorSmall(n);
                    let recovered = '';
                    let chi = null;
                    
                    if(factors){
                        const fp = factors[0], fq = factors[1];
                        const phi2 = (fp-1)*(fq-1);
                        const d2 = modinv(e, phi2);
                        
                        // Decryption: M = C^d mod N
                        const plain = cipher.map(c => powmod(c, d2, n));
                        recovered = decodePairs(plain);
                        
                        // Calculate Chi-squared for validation
                        chi = chi2(freq(recovered), italian_expected);
                    }

                    const out = document.getElementById('rsa-output');
                    out.innerHTML = '';

                    // Metadata Output
                    out.innerHTML += `
                        <div class="mb-4">
                            <div><strong>Public Key (e, n)</strong>: ${e}, ${n}</div>
                            <div><strong>Private Key (d, n)</strong>: ${d}, ${n}</div>
                            <div><strong>Ciphertext Blocks (first 10)</strong>: ${cipher.slice(0,10).join(', ')}...</div>
                            ${factors ? `<div><strong>Factored Modulus</strong>: ${factors[0]} &times; ${factors[1]}</div>` : '<div><strong class="text-red-400">Factorization failed (N too large for demo function).</strong></div>'}
                        </div>
                    `;

                    // Chart Containers
                    const chartsWrap = document.createElement('div');
                    chartsWrap.className = 'grid grid-cols-1 md:grid-cols-2 gap-6 mt-4';
                    chartsWrap.innerHTML = `
                        <div id="orig-chart" class="p-3 bg-gray-800/70 border-2 border-lime-400"></div>
                        <div id="rsa-chart" class="p-3 bg-gray-800/70 border-2 border-red-400"></div>
                    `;
                    out.appendChild(chartsWrap);

                    // Compute and Render Counts
                    const origCounts = Object.keys(freq(s)).reduce((acc, key) => { acc[key] = Math.round(freq(s)[key] * s.length); return acc; }, {});
                    
                    // The "cipher" distribution is actually just the frequency of the ciphertext block value modulo 26, 
                    // which should be statistically flat/random.
                    const rsaCounts = {};
                    for(const c of cipher){ const letter = String.fromCharCode((c % 26) + 97); rsaCounts[letter] = (rsaCounts[letter]||0) + 1; }
                    
                    renderCounts('orig-chart', origCounts, 'Original Plaintext Letter Frequencies', '#lime-400');
                    renderCounts('rsa-chart', rsaCounts, 'Ciphertext Letter Frequencies (C mod 26)', '#red-400');

                    // Final Results
                    if(factors){
                        out.innerHTML += `
                            <div class="mt-4 p-3 bg-gray-800/70 border-2 border-gray-500">
                                <div><strong>Decrypted Plaintext (first 100 chars)</strong>: <code class="text-lime-400">${recovered.slice(0,100)}...</code></div>
                                <div><strong>Statistical Validation ($\chi^2$ Score)</strong>: <code class="text-cyan-400">${chi.toFixed(4)}</code></div>
                            </div>
                        `;
                    }
                    
                    const statusEl = document.getElementById('status');
                    if(statusEl) statusEl.textContent = 'RSA Demo: Complete.';
                }
                
                // --- LLN Global Variable for Chart.js Instance ---
                let llnChartInstance = null;
            
                // --- LLN Simulation Function ---
                function runLlnSimulation() {
                    const N = parseInt(document.getElementById('trialsN').value, 10);
                    const P_str = document.getElementById('probP').value.trim();
                    const P = parseFloat(P_str);

                    const statusEl = document.getElementById('lln-status');
                    if (statusEl) statusEl.textContent = 'Running Simulation...';

                    if (isNaN(N) || N <= 0 || N > 1000000) {
                        if (statusEl) statusEl.textContent = 'Error: Trials (N) must be between 1 and 1,000,000.';
                        return;
                    }
                    if (isNaN(P) || P <= 0 || P >= 1) {
                        if (statusEl) statusEl.textContent = 'Error: Probability (P) must be between 0 and 1 (exclusive).';
                        return;
                    }

                    // Array to store the running average after each trial
                    const runningAverages = [];
                    let successes = 0;
                    
                    // Simulate Bernoulli trials
                    for (let i = 1; i <= N; i++) {
                        const trialResult = Math.random() < P;
                        if (trialResult) {
                            successes++;
                        }
                        // Calculate the running average (sample mean)
                        const currentAverage = successes / i;
                        runningAverages.push(currentAverage);
                    }

                    // Final sample mean
                    const finalSampleMean = successes / N;
                    const finalExpectedMean = P;

                    // Update textual results
                    document.getElementById('lln-results').innerHTML = `
                        <div class="mt-4 p-3 bg-gray-800/70 border-2 border-lime-400">
                            <div><strong>Final Trials (N)</strong>: <span class="text-lime-400">${N.toLocaleString()}</span></div>
                            <div><strong>Expected Probability ($\mathbf{P}$)</strong>: <span class="text-cyan-400">${finalExpectedMean.toFixed(4)}</span></div>
                            <div><strong>Observed Sample Mean</strong>: <span class="text-yellow-400">${finalSampleMean.toFixed(4)}</span></div>
                            <div><strong>Difference</strong>: <code class="text-red-400">${Math.abs(finalSampleMean - finalExpectedMean).toExponential(2)}</code></div>
                        </div>
                    `;

                    // Generate Chart data
                    const labels = Array.from({ length: N }, (_, i) => i + 1);
                    const expectedLine = new Array(N).fill(finalExpectedMean);
                    
                    const ctx = document.getElementById('lln-chart').getContext('2d');
                    
                    // Destroy old chart instance if it exists
                    if (llnChartInstance) {
                        llnChartInstance.destroy();
                    }

                    // Create new Chart.js instance (Line Chart)
                    llnChartInstance = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Sample Mean $\overline{X}$',
                                data: runningAverages,
                                borderColor: 'rgba(250, 250, 250, 0.8)', // White Neon
                                borderWidth: 1,
                                pointRadius: 0,
                                fill: false,
                                tension: 0.1
                            }, {
                                label: 'Expected Mean P',
                                data: expectedLine,
                                borderColor: 'rgba(0, 255, 194, 1.0)', // Accent Neon Green
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false,
                                borderDash: [5, 5]
                            }]
                        },
                        options: {
                            animation: false,
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'logarithmic',
                                    title: { display: true, text: 'Number of Trials (N)', color: '#9ca3af' },
                                    ticks: { color: '#9ca3af' },
                                    grid: { color: '#1f2937' }
                                },
                                y: {
                                    min: 0,
                                    max: 1,
                                    title: { display: true, text: 'Running Average (Proportion)', color: '#9ca3af' },
                                    ticks: { color: '#9ca3af' },
                                    grid: { color: '#1f2937' }
                                }
                            },
                            plugins: {
                                legend: {
                                    labels: { color: 'var(--neon-color)', font: { family: 'monospace' } }
                                },
                                title: {
                                    display: true,
                                    text: 'Convergence of Sample Mean to Expected Probability',
                                    color: 'var(--neon-color)',
                                    font: { family: 'monospace', size: 16 }
                                }
                            }
                        }
                    });
                    
                    if (statusEl) statusEl.textContent = 'LLN Simulation: Complete.';
                }


                // --- Auto-Run on Load ---
                window.onload = function() {
                    // Run RSA demo automatically
                    try { runRsaDemo(); } catch(e) { console.error('Error running RSA demo:', e); }

                    // Set default values for LLN and wire up the button
                    document.getElementById('trialsN').value = 50000;
                    document.getElementById('probP').value = 0.618;
                    const runLlnBtn = document.getElementById('run-lln');
                    if (runLlnBtn) runLlnBtn.addEventListener('click', runLlnSimulation);

                    // Run LLN demo automatically on load
                    try { runLlnSimulation(); } catch(e) { console.error('Error running LLN simulation:', e); }
                };
            </script>
        </section>

        <div class="border-b-4 border-gray-700 my-10"></div>
        
        <!-- === [ SECTION 2: LAW OF LARGE NUMBERS (LLN) ] === -->
        <h2 class="text-4xl font-black uppercase mb-6 text-neon cyber-mono section-header">
            [02] LAW OF LARGE NUMBERS
        </h2>

        <!-- SECTION 2.1: LLN Theory -->
        <h3 class="text-3xl font-bold uppercase text-neon section-header">
            [02.1] THE CONVERGENCE PRINCIPLE
        </h3>

        <p class="text-lg leading-relaxed mb-6">
            The **Law of Large Numbers (LLN)** states that as the number of trials ($\mathbf{N}$) in an experiment increases, the average of the results obtained from the trials (the **sample mean** or **observed probability**) approaches the expected value (the **theoretical probability**). This is the statistical foundation that ensures, over the long run, random events behave predictably.
        </p>

        <div class="code-block-brutal text-center">
            <span class="text-xl font-bold text-gray-400">Sample Mean $\rightarrow$ Expected Value</span><br>
            <span class="formula cyber-mono text-xl md:text-2xl">\overline{X}_N \xrightarrow{N \to \infty} E[X] \equiv P</span>
        </div>

        <!-- SECTION 2.2: LLN Simulation -->
        <section id="lln-simulation" class="mb-12 mt-12 p-6 bg-gray-900/50 brutal-border border-l-4 border-accent-color">
            <h3 class="text-2xl font-bold uppercase text-neon section-header cyber-mono">
                [02.2] SIMULATION: BERNOULLI TRIALS
            </h3>

            <div id="lln-status" class="text-sm text-lime-400 cyber-mono mb-4">Ready to run.</div>

            <!-- Input Controls -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <!-- Trials Input -->
                <div class="flex flex-col">
                    <label for="trialsN" class="text-sm font-mono uppercase mb-1 text-gray-400">Trials (N)</label>
                    <input type="number" id="trialsN" min="10" max="1000000" value="50000" class="cyber-input text-lg">
                    <span class="text-xs text-gray-600 mt-1">Max 1,000,000 for stability.</span>
                </div>
                <!-- Probability Input -->
                <div class="flex flex-col">
                    <label for="probP" class="text-sm font-mono uppercase mb-1 text-gray-400">Probability (P)</label>
                    <input type="number" step="0.001" min="0.001" max="0.999" value="0.618" id="probP" class="cyber-input text-lg">
                    <span class="text-xs text-gray-600 mt-1">Value between 0.001 and 0.999.</span>
                </div>
                <!-- Run Button -->
                <div class="flex items-end">
                    <button id="run-lln" class="cyber-button w-full text-lg">
                        INITIATE LLN CALCULATION
                    </button>
                </div>
            </div>

            <div id="lln-results" class="mb-6">
                <!-- Text results populate here -->
            </div>

            <!-- Chart Display -->
            <div class="code-block-brutal h-96">
                <canvas id="lln-chart"></canvas>
            </div>
            
        </section>


        <!-- Final block maintained to close the article -->
        <div class="p-4 bg-gray-900/70 border-t-4 border-neon mt-8">
            <p class="text-center font-mono text-sm text-gray-500">
                [ END OF LINE / PROCESS TERMINATED ]
            </p>
        </div>

    </main>

    <footer class="bg-black mt-12 p-6 md:p-8 border-t-8 border-neon">
        <div class="container mx-auto text-sm font-mono uppercase tracking-wider text-center text-gray-500">
            [ ASYMMETRIC CRYPTOGRAPHY // STATISTICAL VALIDATION ]
        </div>
    </footer>

</body>
</html>